\documentclass{uebungszettel}
\newcommand{\utitle}{Tag 7}

\begin{document}

\begin{aufg}
Denke dir einen sinnvollen Namen aus für ein Modul, dass Vektorrechnung auf $\R^n$ implementiert. Vektoren sollen \verb|double|-Arrays mit der Länge $n$ sein. Implementiere die nachfolgenden Funktionen:
\begin{enumerate}
	\item eine Funktion, die genügend Speicher für einen Vektor reserviert und einen Pointer darauf zurück gibt
	\item Vektoraddition
	\item Vektorsubtraktion
	\item Produkt eines Vektors mit einer skalaren Größe
	\item Skalarprodukt zweier Vektoren
	\item eine Funktion, die einen Vektor auf der Konsole aus gibt
\end{enumerate}
Zur Verdeutlichung hier ein Beispiel einer Funktion, die einen Vektor aufnimmt und ihn mit dem Nullvektor initialisiert:
\begin{codelisting}
\begin{lstlisting}[numbers=left,numberstyle=\tiny,frame=tlrb]
void vector_make0(double *v, int n) { 
	int i;
	for(i=0; i<n; i++) v[i] = 0;
}
\end{lstlisting}
\end{codelisting}
\end{aufg}

\begin{aufg}
Diese Aufgabe läuft auf die Implementierung des Merge-Sort Algorithmus hinaus.
\begin{enumerate}
\item Implementiere eine Funktion \verb|merge|, die zwei bereits sortierte (eventuell verschieden große) Arrays als Argumente erhält, diese zu einem sortieren Array kombiniert und dieses zurück liefert. 
\item Die Funktion \verb|mergesort| selbst soll ein Array in zwei (möglichst gleich große) Teilarrays zerlegen, diese Teilarrays rekursiv durch einen weiteren Aufruf von \verb|mergesort| sortieren und die so sortierten Teilarrays mit der \verb|merge|-Funktion kombinieren. 

Wenn die Funktion ein Array der Länge $1$ oder $0$ übergeben bekommt, so tut die Funktion nichts, da das Array bereits sortiert ist: Dies beendet die Rekursion.
\end{enumerate}

Hier als Tipp ein Vorschlag für die Signaturen der beiden Funktionen:
\begin{codelisting}
\begin{lstlisting}[numbers=left,numberstyle=\tiny,frame=tlrb]
int *merge(int *list1, int n, int *list2, int m);
void mergesort(int *list, int n);
\end{lstlisting}
\end{codelisting}
\end{aufg}

\begin{aufg} Implementiere einige Funktionen um mit quadratischen Matrizen umzugehen:
\begin{enumerate}
\item Eine Funktion, die Speicher für eine quadratische Matrix allokiert, eine um ihn freizugeben, eine um sie auszugeben und eine um sie zur Einheitsmatrix zu initialisieren (das ist die Matrix mit $1$en auf der Hauptdiagonale und $0$en sonst):
\begin{codelisting}
\begin{lstlisting}[numbers=left,numberstyle=\tiny,frame=tlrb]
double **matrix_alloc(int n);
void     matrix_free(double **A, int n);
void     matrix_print(double **A, int n);
double **matrix_id(double **A, int n);
\end{lstlisting}
\end{codelisting}
\item Eine Funktion um eine Matrix zu transponieren (d.h. an der Hauptdiagonale ``zu spiegeln'')
\item Eine Funktion, die zwei solche Matrizen miteinander multipliziert und eine neue Matrix zurück gibt. Für zwei $n \times n$-Matrizen $A = (a_{ij})$ und $B = (b_{ij})$ ist $A \cdot B = C = (c_{ij})$ über folgende Formel definiert: \[
c_{ij} = \sum_{k=1}^n a_{ik} b_{kj}
\]
\end{enumerate}
\end{aufg}


\end{document}
