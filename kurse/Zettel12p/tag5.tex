\documentclass{uebungszettel}
\usepackage{algorithm,algorithmic}
\floatname{algorithm}{Algorithmus}
\newcommand{\SET}{\textbf{set}\ }
\newcommand{\CHOOSE}{\textbf{choose}\ }
\newcommand{\GOTO}{\textbf{goto}\ }
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}
\renewcommand{\listalgorithmname}{Algorithms}
\renewcommand{\algorithmiccomment}[1]{\\/* #1 */}
\newcommand{\ah}[2]{\ \\* \emph{(#1, #2)}\\}
\newcommand{\utitle}{Tag 5}
\begin{document}

\begin{aufg} Implementiere eine c-Datei zu folgender Header-Datei: 
\begin{codelisting}
\begin{lstlisting}[numbers=left,numberstyle=\tiny,frame=tlrb]
/* gibt die Länge eines Strings zurück */
int str_len(char *s); 

/* gibt 0 zurück, wenn zwei strings gleich 
 * sind und 1 sonst */
int str_cmp(char *s1, char *s2);

/* kopiert s nach d und gibt d zurück */
char *str_cpy(char *d, char *s);

/* hänge s2 and s1 an und gib s1 zurück */ 
char *str_cat(char* s1, char* s2)
\end{lstlisting}
\end{codelisting}
und teste deinen code mit folgendem modul:
\begin{codelisting}
\begin{lstlisting}[numbers=left,numberstyle=\tiny,frame=tlrb]
#include <stdio.h>
#include "mystrings.h"

int main() {
	char p[100] = "Pepsi ";
	char c[100] = "Coca ";
	char suffix[10] = "Cola";
	char out[100];
	str_cpy(out,p); 
	str_cat(out,suffix); 
	str_cpy(p,out);
	str_cpy(out,c);
	str_cat(out,suffix);
	str_cpy(c,out);
	if (str_cmp(p,c)) {
		printf("%s",p);
		printf(" is not ");
		printf("%s",c);
		printf("\n");
	}
	return 0;
}
\end{lstlisting}
\end{codelisting}
\end{aufg}



\begin{aufg} Implementiere einige Funktionen um mit quadratischen Matrizen umzugehen:
\begin{enumerate}
\item Eine Funktion, die Speicher für eine quadratische Matrix allokiert, eine um ihn freizugeben, eine um sie auszugeben und eine um sie zur Einheitsmatrix zu initialisieren (das ist die Matrix mit $1$en auf der Hauptdiagonale und $0$en sonst):
\begin{codelisting}
\begin{lstlisting}[numbers=left,numberstyle=\tiny,frame=tlrb]
double **matrix_alloc(int n);
void     matrix_free(double **A, int n);
void     matrix_print(double **A, int n);
double **matrix_id(double **A, int n);
\end{lstlisting}
\end{codelisting}
\item Eine Funktion um eine Matrix zu transponieren (d.h. an der Hauptdiagonale ``zu spiegeln'')
\item Eine Funktion, die zwei solche Matrizen miteinander multipliziert und eine neue Matrix zurück gibt. Für zwei $n \times n$-Matrizen $A = (a_{ij})$ und $B = (b_{ij})$ ist $A \cdot B = C = (c_{ij})$ durch $c_{ij} = \sum_{k=1}^n a_{ik} b_{kj}$ definiert.
\end{enumerate}
\end{aufg}

\begin{aufg}
Diese Aufgabe läuft auf die Implementierung des Merge-Sort Algorithmus hinaus.
\begin{enumerate}
\item Implementiere eine Funktion \verb|merge|, die zwei bereits sortierte (eventuell verschieden große) Arrays als Argumente erhält, diese zu einem sortieren Array kombiniert und dieses zurück liefert. 
\item Die Funktion \verb|mergesort| selbst soll ein Array in zwei (möglichst gleich große) Teilarrays zerlegen, sich für diese Teilarrays selbst aufrufen und danach die dann sortierten Teilarrays mit der \verb|merge|-Funktion kombinieren. Erhält die Funktion ein Array mit keinem oder einem Element so belässt es dieses Array wie es ist, dann ist es nämlich bereits sortiert.
\item Besorge dir die Datei \verb|daten.h|, sortiere das darin definierte Array und schreibe es sortiert in eine Datei.
\end{enumerate}

Hier als Tipp ein Vorschlag für die Signaturen der beiden Funktionen:
\begin{codelisting}
\begin{lstlisting}[numbers=left,numberstyle=\tiny,frame=tlrb]
int *merge(int *list1, int n, int *list2, int m);
void mergesort(int *list, int n);
\end{lstlisting}
\end{codelisting}

\end{aufg}

\rofoot{SS12}
\end{document}
