\documentclass{uebungszettel}
\newcommand{\utitle}{Tag 6}

\begin{document}

\begin{aufg} Implementiere eine c-Datei zu folgender Header-Datei: 
\begin{codelisting}
\begin{lstlisting}[numbers=left,numberstyle=\tiny,frame=tlrb]
/* Gibt die Länge eines Strings zurück. */
int str_len(char *s); 

/* Gibt 0 zurück, wenn zwei strings gleich 
   sind und 1 sonst. */
int str_cmp(char *s1, char *s2);

/* Kopiert s nach d und gibt d zurück. Es ist nicht
   Aufgabe von str_cpy, dafür zu sorgen, dass bei d
   genug Platz für s ist. */
char *str_cpy(char *d, char *s);

/* Hänge s2 and s1 an und gib s1 zurück. Es ist nicht
   Aufgabe von str_cat, dafür zu sorgen, dass hinter
   s1 genügend legal  beschreibbarer Speicher ist. */ 
char *str_cat(char* s1, char* s2)

/* Allokiere neuen Speicher für eine Kopie von s. */
char *str_dup(char *s);

/* Falls der string needle im string haystack an
   der stelle i das erste mal vorkommt, gib den
   pointer haystack+i zurück. 
   Andernfalls, liefere NULL. */
char *str_str(char *haystack, char *needle);
\end{lstlisting}
\end{codelisting}
\end{aufg}

\begin{aufg}
Implementiere den sogenannten \emph{Bucket-Sort} Algorithmus für arrays \verb|arr| von \verb|short int|:
\begin{enumerate}
  \item Finde das Maximum \verb|m| aus \verb|arr|. 
  \item Erstelle dann ein \verb|unsigned|-Array \verb|buckets| mit \verb|m+1| Elementen und sorge dafür, dass an der \verb|i|-ten Stelle die Anzahl der \verb|i|'s steht, die in \verb|arr| vorkommen.
  \item Iteriere über \verb|buckets| und sortiere zurück nach \verb|arr|: Schreibe dabei \verb|k| mal das Element \verb|i|, wenn an der \verb|i|-ten Stelle von \verb|buckets| ein \verb|k| steht.
\end{enumerate}
\end{aufg}

\newpage

\begin{aufg}
Schreibe ein Modul \verb|arrayhelpers|, das einige nützliche Funktion zum \verb|int|-Array-Handling enthält:
\begin{enumerate}
\item Array zeilenweise oder mit Kommata getrennt ausgeben
\item Array sortieren
\item Alle Felder eines Arrays mit einem Wert initialisieren
\item Array um $1$ rotieren (d.h. das hinterste Element an erste Stelle schreiben und alle anderen Elemente um eins nach hinten schieben)
\item Array um $k$ rotieren
\item Array umdrehen
\item Ein Array in einem anderen suchen und die Position zurück geben. Sollte das Array nicht im anderen enthalten sein, so soll der Rückgabewert $-1$ sein.

\emph{Beispiel:} 
\begin{codelisting}
\begin{lstlisting}[numbers=left,numberstyle=\tiny,frame=tlrb]
int A[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
int B[3] = {4, 5, 6}
int C[2] = {5, 7}
int D[2] = {9, 10}
\end{lstlisting}
\end{codelisting}
Hier gilt: \verb|B| ist an $3$-ter Stelle in \verb|A| enthalten und \verb|D| an $8$-ter. Das Array \verb|C| ist garnicht in \verb|A| enthalten, darum wird der Rückgabewert $-1$ sein.

\end{enumerate}
\end{aufg}


\begin{aufg}* Diese Aufgabe ist schwierig, lass dir helfen, wenn du sie lösen möchtest	:
\begin{enumerate}
\item Schreibe eine Funktion, die prüft, ob ein Array eine Permutation ist.
\item Schreibe eine Funktion, die ein Array und ein Permutationsarray entgegennimmt und das Array entsprechend permutiert.
\end{enumerate}
\end{aufg}


\end{document}
