\documentclass{uebungszettel}
\begin{document}

\begin{aufg} Implementiere eine Funktion die zu einem gegebenen Funktionenpointer $f:\R \rightarrow \R$, einen Dateinamen, einer Schrittweite $s \in \R$, einer Startstelle $x_1$ und einer Endstelle $x_2$ die Wertetabelle der Funktion zwischen $x_1$ und $x_2$ zur Schrittweite $s$ speichert. Dabei sollen $x$ und $f(x)$ durch einen Tabulator getrennt werden und jedes Paar $(x, f(x))$ in einer eigenen Zeile stehen.
\end{aufg}

\begin{aufg}
In dieser Aufgabe geht es um numerische Integration.
\begin{enumerate}
\item Implementiere eine Integrationsfunktion, die das Intervall $[a, b]$ in $n$ gleich große Teile aufteilt, für diese jeweils die Trapezsumme (aus der Vorlesung) berechnet und diese aufsummiert:

\begin{codelisting}
\begin{lstlisting}[numbers=left,numberstyle=\tiny,frame=tlrb]
double integrate(double a, double b, 
  double (*f)(double), unsigned int n); 
\end{lstlisting}
\end{codelisting}

\item Schreibe nun eine Funktion, die nicht die Anzahl der Teilintervalle erhält, sondern eine ``Fehlertoleranz'' $e$. Die Funktion die Aufteilung solange verfeinern, bis sich der approximierte Wert für das Integral durch eine Verfeinerung nur noch um weniger als $e$ ändern würde. 
\end{enumerate}
\end{aufg}

\begin{aufg} 
Sortiere ein Array deiner \verb|rationals| mithilfe von \verb|qsort|.
\end{aufg}

\begin{aufg} Schreibe eine Funktion, die mithilfe von \verb|qsort| ein Array von Strings lexikographisch (wie im 
Telefonbuch) sortiert. Das heißt, dass erst nach der ersten Stelle sortiert wird, dann nach der Zweiten usw. In der 
\verb|<string.h>| liegt eine Vergleichsfunktion für diese Situation vor: \verb|strcmp|. Als Beispiel hier eine 
lexikographisch sortierte Liste:
\begin{codelisting}
\begin{lstlisting}[numbers=left,numberstyle=\tiny,frame=tlrb]
1
10
133
2
2344
Hallo
Thor
Tor
\end{lstlisting}
\end{codelisting}
\end{aufg}

\newpage

\begin{aufg}
Schreibe ein Programm, dass ein Labyrinth aus einer Datei einliest:
{\tt
\lstset{language=Delphi}
\begin{lstlisting}
XXXXXXXXXXXXXXXX
X X XXXXXXXXXX*X
X$X XX     XXX X
X X XX XXX XXX X
X   XX XXX XXX X
XXX X   XX XXX X
XXX   X        X
XXXXXXXXXXXXXXXX
\end{lstlisting}
}
\emph{Bemerkung: } Wir spezifizieren das Labyrinth hier nicht viel näher, entscheide dich selbst vorher was für ein Format die Datei haben soll und welche Einschränkungen du daran stellst: Soll die Größe des Labyrinths variabel sein oder fest? Soll die Größe in der ersten Zeile der Datei stehen oder nicht? Soll das Labyrinth quadratisch sein oder nicht? Soll es außen herum immer mit $X$en begrenzt sein oder hast du vielleicht eine andere Lösung?\\
Das Programm soll einen Weg vom Startpunkt (dem Stern, dem Geburtsort) zum Dollar (dem Schatz) finden. Die $X$e sind Wände und Leerzeichen sind Pfade. Markiere einen Weg mit Punkten und gebe das Labyrinth mit Weg in der Konsole aus.

{\tt
\lstset{language=Delphi}
\begin{lstlisting}
XXXXXXXXXXXXXXXX
X X XXXXXXXXXX*X
X$X XX     XXX.X
X.X XX XXX XXX.X
X...XX XXX XXX.X
XXX.X...XX XXX.X
XXX...X........X
XXXXXXXXXXXXXXXX
\end{lstlisting}
}
\end{aufg}
\end{document}
