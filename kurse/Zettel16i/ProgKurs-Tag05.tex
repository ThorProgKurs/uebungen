\documentclass{uebungszettel}
\begin{document}

\begin{aufg}
Schreibe Funktionen \verb|square_to| und \verb|root_to|, die einen \verb|double|-Pointer entgegen nehmen, die dort stehende Variable quadrieren bzw. daraus die Wurzel ziehen und das Ergebnis sowohl zurück geben als auch an die gleiche Speicherstelle schreiben.
\end{aufg}

\begin{aufg} In dieser Aufgabe geht es um Sortieralgorithmen. Definiere dir ein Test-Array mit einer \emph{festen} Anzahl von Einträgen mit denen du den Algorithmus testest. Lagere diesen Algorithmus noch nicht in eine Funktion aus (du weiß ja noch gar nicht, wie man Arrays an Funktionen übergibt).
\begin{enumerate} 
\item Implementiere folgenden Sortieralgorithmus: Sortiere das kleines Element an die erste Stelle, dann das zweitekleinste Element an die zweite Stelle usw.
\item Der obige Sortieralgorithmus hat Komplexität $\mathcal O(n^2)$ (wobei $n$ die Anzahl der Elemente ist). Aus theoretischer Sicht sind Sortieralgorithmen bis zu $\mathcal O(n \log(n))$ realisierbar. Wenn man nun aber die größer der zu sortierenden Eintrag einschränkt (z.B. sei die größte zu sortierende Zahl $20000$) ist es sogar möglich einen \emph{linearen} Sortieralgorithmus zu implementieren, also $\mathcal O(n)$. Dazu stellt man sich für jede Zahl einen leeren ``Bucket'' (Korb) vor. Dann geht man die Liste der zu sortierenden Einträge durch und für ein Verkommen der Zahl $k$ einen Ball in den $k$-ten Bucket. Danach geht man die Buckets vom ersten bis zu letzten durch. Ist am $k$-ten Bucket angekommen und es liegen $j$ Bälle darin, dann schreibe sukzessive $j$ mal die Zahl $k$ in die zu sortierende Liste. Da die Bälle genau den zu sortierenden Zahlen entsprechen ist die Liste nachher sortiert. 
\end{enumerate}
\end{aufg}

\begin{aufg} Implementiere eine c-Datei zu folgender Header-Datei: 
\begin{codelisting}
\begin{lstlisting}[numbers=left,numberstyle=\tiny,frame=tlrb]
/* gibt die Laenge eines Strings zurueck */
int str_len(char *s); 

/* gibt 0 zurueck, wenn zwei strings gleich 
 * sind und 1 sonst */
int str_cmp(char *s1, char *s2);

/* kopiert s nach d und gibt d zurueck */
char *str_cpy(char *d, char *s);

/* haenge s2 and s1 an und gib s1 zurueck */ 
char *str_cat(char* s1, char* s2);
\end{lstlisting}
\end{codelisting}
und teste deinen Code mit der c-Datei auf der folgenden Seite.

\begin{codelisting}
\begin{lstlisting}[numbers=left,numberstyle=\tiny,frame=tlrb]
#include <stdio.h>
#include "mystrings.h"

int main() {
	char p[100] = "Pepsi ";
	char c[100] = "Coca ";
	char suffix[10] = "Cola";
	char out[100];
	str_cpy(out,p); 
	str_cat(out,suffix); 
	str_cpy(p,out);
	str_cpy(out,c);
	str_cat(out,suffix);
	str_cpy(c,out);
	if (str_cmp(p,c)) {
		printf("%s",p);
		printf(" is not ");
		printf("%s",c);
		printf("\n");
	}
	return 0;
}
\end{lstlisting}
\end{codelisting}
\end{aufg}

\end{document}
